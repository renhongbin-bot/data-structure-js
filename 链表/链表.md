# 链表和数组一样，可用于存储一系列的元素，但是链表和数组的实现机制不一样

# 数组的缺点：

## 数组的创建通常需要申请一段连续的内存空间（一整块内存），并且大小是固定的（大多数编程语言数组都是固定的），所以当当前数组不能满足容量需求时，需要扩容（一般情况是申请一个更大的数组，比如 2 倍，然后将原数组的元素复制过去）

## 而且在数组开头或者中间插入数据的成本很高，需要进行大量元素的位移

# 链表

## 要存储多个元素，另一个选择是链表

## 但不同于数组，链表中的元素在内存中不必是连续的空间

## 链表的每个元素由一个存储元素本身的节点和一个指向下一个元素的引用（有些语言称为指针或者连接）组成

# 链表的优点：

## 内存空间不必是连续的，可以充分利用计算机的内存，实现灵活的内存动态管理

## 链表不必在创建时就确定大小，并且大小可以无限延伸下去

## 链表在插入和删除数据时，时间复杂度可以达到 O(1),相对数组效率高得多

# 链表的缺点：

## 链表访问任何一个位置的元素时,都需要从头开始访问（无法跳过第一个元素访问任何一个元素）

## 无法通过下标直接访问元素，都需要从头一个一个访问，直到找到对应元素

<!-- 单向链表 -->

# 只能从头遍历到尾或者从尾遍历到头

# 也就是链表相连过程是单向的

# 实现原理是上一个链表中有一个指向下一个引用

<!-- 单向链表的缺点 -->

# 我们可以很轻松的到达下一个节点，但是回到前一个节点是很难的

<!-- 链表的常见操作 -->

# append(element): 向链表尾部添加一个新的项

# insert(position, element): 向链表的特定位置插入一个新的项

# get(position): 获取对应位置的元素

# indexOf(element): 返回元素在链表中的索引。如果链表中没有该元素返回-1

# update(position): 修改某个位置的元素

# removeAt(position): 从链表中的特定位置移除一项

# remove(element): 从链表中移除一项

# isEmpty(): 如果链表不包含任何元素，返回 true，如果链表长度大于 0 返回 false

# size(): 返回链表包含的元素个数。与数组的 length 属性类似

# toString(): 由于链表使用了 Node 类，就需要重写继承自 JavaScript 对象默认的 toString 方法，让其只输出元素的值

:cat:阿萨德
:earth_asia:
